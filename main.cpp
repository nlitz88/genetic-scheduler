#include <iostream>
#include <fstream>

#include <random>
#include <time.h>
#include <chrono>

#include "Schedule.h"
#include "Scheduler.h"
#include "Optimizer.h"


// This is where the various classes and scheduler optimization aglorithm will be tested.
// This file will eventually server as a broker to the various remote notes that it connects to?

int main() {

    // Seed random number generator
    srand(time(0));

    auto startTime = std::chrono::high_resolution_clock::now();


    // Old testing can be found in previous commits.
    


    // *******************************************************************************
    //
    //                             SCHEDULE GENERATION
    //
    // *******************************************************************************



    // ************************** ALGORITHM CONSTANTS **************************


    // Defines how large a population should be. Initially this is how many random schedules to initially generate and then how many schedules need to be generated by the elite.
    const int POPULATION_SIZE = 1000;

    // Defines the number in the elite population to be used to create the next generation.
    const int ELITE_SIZE = 150;

    // Defines the number of times a new generation should be created in the event an optimal solution is not found.
    const int MAX_ITERATIONS = 1000;

    // Defines the maximum number of times a new population is created when there is no improvement in fitness. That is, if the same best fitness value occurs STABLE_ITERATIONS times in a row, the algorithm with terminate regardless if MAX_ITERATIONS is reached.
    const int STABLE_ITERATIONS = 10;

    // Max acceptable fitness of a schedule generated.
    const int MAX_ACCEPTED_FITNESS = 0;




    // Optimizer object that will calculate fitness for each schedule.
    Optimizer optimizer;

    // Create new Scheduler. Pass in filename so that it can generate collection of sections.
    Scheduler scheduler = Scheduler("sections.txt");


    // ************************** GENETIC ALGORITHM **************************


    // Collection of Schedules for POPULATION and ELITE.
    Schedule** population = new Schedule* [POPULATION_SIZE];
    Schedule** elite = new Schedule* [ELITE_SIZE];
    

    // Generate initial population.
    population = scheduler.generateSchedules(POPULATION_SIZE);

    // Initially rank population. Use Optimizer to get/assign fitness to each schedule.
    for(int s = 0; s < POPULATION_SIZE; ++s) {
        population[s]->setFitness(optimizer.getScheduleFitness(population[s]));
    }


    // DO-WHILE???
    

    // Initial bestFit = population[0]
    Schedule* bestFit = population[0];
    
    int iterations = 0;
    int timesSame = 0;


    // while(bestFit->getFitness() > MAX_ACCEPTED_FITNESS && iterations < MAX_ITERATIONS && timesSame < STABLE_ITERATIONS) {
    while(bestFit->getFitness() > MAX_ACCEPTED_FITNESS && iterations < MAX_ITERATIONS) {


        // IF fitness of best schedule hasn't changed over STABLE_ITERATIONS times, then regenerate the initial population and try again!
        if(timesSame == STABLE_ITERATIONS) {

            timesSame = 0;

            std::cout << "\nReleasing old population and generating new!\n\n";

            // Release memory maintaining old population of schedule objects.
            for(int p = 0; p < POPULATION_SIZE; ++p) {
                delete population[p];
            }
            delete [] population;

            // Generate new population of schedule objects.
            population = scheduler.generateSchedules(POPULATION_SIZE);

            // Assign new best fit.
            bestFit = population[0];
            
        }


        // Use Optimizer to get/assign fitness to each schedule.
        for(int s = 0; s < POPULATION_SIZE; ++s) {
            population[s]->setFitness(optimizer.getScheduleFitness(population[s]));
        }


        // Sort population by fitness from most fit --> least fit (i.e., smallest fitness to largest) (Selection sort)
        int mostFitIndex = 0;
        Schedule* temp;

        for(int start = 0; start < POPULATION_SIZE - 1; ++start) {

            mostFitIndex = start;

            for(int e = start; e < POPULATION_SIZE; ++e) {

                if(population[e]->getFitness() < population[mostFitIndex]->getFitness()) {
                    mostFitIndex = e;
                }

            }

            // If maxIndex != start, then a more fit schedule (smaller fitness) has been found, and a swap must be performed.
            if(mostFitIndex != start) {

                temp = population[start];
                population[start] = population[mostFitIndex];
                population[mostFitIndex] = temp;

            }
            
        }

        // Print out sorted result.
        // for(int s = 0; s < POPULATION_SIZE; ++s) {
        //     std::cout << "Schedule " << s << ": " << population[s]->getFitness() << std::endl;
        // }
        // std::cout << std::endl << population[0]->toString() << std::endl;
        std::cout << "Iteration " << iterations + 1 << " - Best Schedule Fitness: " << population[0]->getFitness() << std::endl << std::endl;



        // Extract elite.
        for(int e = 0; e < ELITE_SIZE; ++e) {

            elite[e] = population[e];

        }
        // Print out Elite.
        // std::cout << "Elite Schedule Fitnesses: \n";
        // for(int e = 0; e < ELITE_SIZE; ++e) {
        //     std::cout << e << " : " << elite[e]->getFitness() << std::endl;
        // }
        // std::cout << "\n\n";


        // NOW, compare fitness of this generation's best to that of previous. Sort of just an intermediary step to track the progress of the genetic algorithm.

        // If best of newest generation same as last, ++timesSame.
        if(elite[0]->getFitness() == bestFit->getFitness()) {
            ++timesSame;
            std::cout << "Same fitness as last best!\n";
        } 
        // Otherwise, reset timesSame and examine the new best.
        else {

            // std::cout << "NOT Same fitness as last best!\n";

            timesSame = 0;

            // If most fit of newest generation is better than the rest so far, then set it as the new best.
            if(elite[0]->getFitness() < bestFit->getFitness()) {
                bestFit = elite[0];
            }

        }





        // THEN, HERE IS WHERE THE ACTUAL CROSSOVER/MUTATIONS SHOULD OCCUR. That way, when it loops around again, it will be examining the new population.
        


        // Also, depending on how this works, should I release memory of all other schedules left in the population?? (this should subequently have each's sections and meetings destroyed).


        // Crossover:
        //      For each elite schedule, choose another random schedule (from the elites (that's not the current)).
        //          Take one half of that other schedule (alphabetically) and give it to the current elite, and give the second half of the current to the other
        //          Maybe this is how it works???


        // First, (this is unecessary, but) place elites at top of population
        for(int e = 0; e < ELITE_SIZE; ++e) {

            population[e] = elite[e];

        }


        // Two Schedule pointers to maintain the two new Schedules that will be spliced together.
        Schedule* newSchedA = nullptr;
        Schedule* newSchedB = nullptr;

        // Two Schedule pointers to maintain the two random elites selected to take sections from.
        Schedule* eliteA = nullptr;
        Schedule* eliteB = nullptr;

        // Number of sections in either schedule.
        int numSections = 0;

        // Then, this is where we REGENERATE the rest of the population with new, hopefully BETTER schedules.
        // p += 2 here, as with each crossover, two new schedules are being created. Therefore, step through population and regenerate two at a time.
        for(int p = ELITE_SIZE; p < POPULATION_SIZE; p += 2) {


            // First, release memory of old schedule objects
            delete population[p];
            delete population[p+1];

            // Then, crossover. Maybe if I have time introduce mutations somewhere in the algo.


            // Create new Schedule objects (this instructor just creates a Schedule with a blank collection of pointers to sections) (Use addSection to add).
            newSchedA = new Schedule();
            newSchedB = new Schedule();


            // Get two random elite Schedules.
            eliteA = elite[(rand() % ELITE_SIZE)];
            do {
                eliteB = elite[(rand() % ELITE_SIZE)];
            } while(eliteB == eliteA);


            // Get number of sections first. Just use one of the elites to get num sections.
            numSections = eliteA->getNumSections();
            

            // First, get a random section to act as the "split point."
            int splitPoint = rand() % numSections;


            // Give newSchedA all sections from eliteA up to section splitPoint, and then all the rest after (and including) splitPoint to newSchedA from eliteB
            // And vice versa for newSchedB
            for(int s = 0; s < splitPoint; ++s) {

                // Add new Section object (copied from section of eliteA) to newSchedA.
                newSchedA->addSection(new Section(*(eliteA->getSections()[s])));
                // Do the same for newSchedB, but add the first SPLITPOINT sections from eliteB for newSchedB instead!
                newSchedB->addSection(new Section(*(eliteB->getSections()[s])));

            }

            // Give all the rest of the sections (including splitPoint section) from eliteB to newSchedA, and all the rest from eliteA to newSchedB
            for(int s = splitPoint; s < numSections; ++s) {

                newSchedA->addSection(new Section(*(eliteB->getSections()[s])));
                newSchedB->addSection(new Section(*(eliteA->getSections()[s])));

            }


            // Finally, add new schedules to population.
            population[p] = newSchedA;
            population[p+1] = newSchedB;

        }


        ++iterations;


    }




    auto stopTime = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(stopTime - startTime);



    std::cout << std::endl
        << "******************** RESULTS ******************\n\n"
        << ((timesSame == STABLE_ITERATIONS && bestFit->getFitness() > MAX_ACCEPTED_FITNESS) ? "SCHEDULE DID NOT MEET " + std::to_string(MAX_ACCEPTED_FITNESS) + "\n": "")
        << "Best schedule fitness: " << bestFit->getFitness() << std::endl
        << "Iterations: " << iterations << std::endl
        << "Main execution time: " << duration.count() << " ms == " << duration.count() / 1000.0 << " s" << std::endl << std::endl
        << "***********************************************\n\n";



    std::cout << std::endl 
              << "**** Schedule With Best Fitness Breakdown ****\n\n";

    optimizer.displayFitnessBreakdown(bestFit);

    std::cout << "\n***********************************************\n\n";


    std::cout << bestFit->toString() << std::endl;



    return 0;


}